'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var INDENT = '  ';

var lispyTraverser = {
  NumberLiteral: {
    onEnter: function onEnter(_ref, node) {
      var code = _ref.code,
          indentLevel = _ref.indentLevel;

      return {
        code: code + INDENT.repeat(indentLevel) + node.value + ',\n',
        indentLevel: indentLevel
      };
    }
  },
  StringLiteral: {
    onEnter: function onEnter(_ref2, node) {
      var code = _ref2.code,
          indentLevel = _ref2.indentLevel;

      return {
        code: code + INDENT.repeat(indentLevel) + '\'' + node.value + '\',\n',
        indentLevel: indentLevel
      };
    }
  },
  CallExpression: {
    onEnter: function onEnter(_ref3, node) {
      var code = _ref3.code,
          indentLevel = _ref3.indentLevel;

      return {
        code: code + INDENT.repeat(indentLevel) + node.callee + '(\n',
        indentLevel: indentLevel + 1
      };
    },
    onExit: function onExit(_ref4, node) {
      var code = _ref4.code,
          indentLevel = _ref4.indentLevel;

      return {
        code: code + INDENT.repeat(indentLevel - 1) + ')\n',
        indentLevel: indentLevel - 1
      };
    }
  }
};

var traverseNode = function traverseNode(node, traverser, state0) {
  var onEnter = traverser[node.type].onEnter || function (x) {
    return x;
  };
  var onExit = traverser[node.type].onExit || function (x) {
    return x;
  };
  var state1 = onEnter(state0, node);
  var state2 = node.type !== 'CallExpression' ? state1 : node.arguments.reduce(function (stateX, node) {
    return traverseNode(node, traverser, stateX);
  }, state1);
  var state3 = onExit(state2, node);
  return state3;
};

var generateJavascript = function generateJavascript(ast) {
  var rootNode = ast.body;

  var _traverseNode = traverseNode(rootNode, lispyTraverser, {
    code: '/** Generated by lispy-compiler **/\n\n',
    indentLevel: 0
  }),
      code = _traverseNode.code;

  return code;
};

exports.default = generateJavascript;